# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sysnow, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustar, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustarnow, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
br
rep(FALSE, 12)
induced_subgraph(br, vids=rep(FALSE, 12))
computeSystemSurvivalSignature(induced_subgraph(br, vids=rep(FALSE, 12)))
V(br)
computeSystemSurvivalSignature(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))
)
induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE)))
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))) == c("s", "t")
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))) %in% c("s", "t")
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)] - tnow
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustarnow, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
# TODO: catch error when sysnow now contains vertices s and t only (suddenly all fails)
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.75, trepa = 0, seqlen = 401, prior = FALSE)
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 8,  M = 12, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
brsim1
library(actuar) # provides dinvgamma(x, shape, scale) where shape = alpha and scale = beta
library(ReliabilityTheory)
library(ggplot2)
library(reshape2)
library(gridExtra)
head(brsim1)
dim(brsim1)
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
dim(brsim1pr)
head(brsim1pr)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
nnynlist <- function(n0y0list, ftslist, ctslist, beta){
K <- length(n0y0list)
res <- list(1:K)
for (k in 1:K){
res[[k]] <- nnyn(n0y0[[k]], ftslist[[k]], ctslist[[k]], beta[k])
}
}
list(1:4)
as.list(1:4)
nnynlist <- function(n0y0list, ftslist, ctslist, beta){
K <- length(n0y0list)
res <- as.list(1:K)
for (k in 1:K){
res[[k]] <- nnyn(n0y0[[k]], ftslist[[k]], ctslist[[k]], beta[k])
}
}
list(c(1,1), c(1,2))
nnynlist(list(c(1,1), c(1,2)), list(c(1,1), rep(3,3)), list(2, rep(4,4)), c(1.2,2))
nnyn <- function(n0y0, fts, cts, beta)
c(nn(n0y0[1], fts), yn(n0y0[1], n0y0[2], fts, cts, beta))
nn <- function(n0, fts)
n0 + length(fts)
yn <- function(n0, y0, fts, cts, beta)
(n0*y0 + sum(fts^beta) + sum(cts^beta)) / (n0 + length(fts))
nnyn <- function(n0y0, fts, cts, beta)
c(nn(n0y0[1], fts), yn(n0y0[1], n0y0[2], fts, cts, beta))
nnynlist(list(c(1,1), c(1,2)), list(c(1,1), rep(3,3)), list(2, rep(4,4)), c(1.2,2))
asdf <- list(c(1,1), c(1,2))
length(asdf)
nnynlist <- function(n0y0list, ftslist, ctslist, beta){
K <- length(n0y0list)
res <- as.list(1:K)
for (k in 1:K){
res[[k]] <- nnyn(n0y0list[[k]], ftslist[[k]], ctslist[[k]], beta[k])
}
}
nnynlist(list(c(1,1), c(1,2)), list(c(1,1), rep(3,3)), list(2, rep(4,4)), c(1.2,2))
nnynlist <- function(n0y0list, ftslist, ctslist, beta){
K <- length(n0y0list)
res <- as.list(1:K)
for (k in 1:K){
res[[k]] <- nnyn(n0y0list[[k]], ftslist[[k]], ctslist[[k]], beta[k])
}
res
}
nnynlist(list(c(1,1), c(1,2)), list(c(1,1), rep(3,3)), list(2, rep(4,4)), c(1.2,2))
head(brsim1)
dim(brsim1)
dim(brsim1pr)
brsim1pr
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
brsim1pr
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 1, hor = 4, tprep = 0.1, trepa = 0, seqlen = 401, prior = FALSE)
brsim1
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 4,  M = 4, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim0
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 3.6,  M = 3.7, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim0
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.25, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim0
brsim0$tnow[brsim0$failed]
min(brsim0$tnow[brsim0$failed])
brsim1
brsim1pr
brsim1pr$tnow[brsim1pr$failed]
min(brsim1pr$tnow[brsim1pr$failed])
any(brsim1pr$failed)
any(brsim1$failed)
brfts8
sapply(brfts8, length)
head(brsysign)
brfts8
unlist(brfts8)
brsim1pr
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 8,  M = 12, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
brsim1pr
0.2/3.5
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 8,  M = 12, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
brsim1$res
brsim1
0.2/8.5
brcompftssim0 <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 3.6,  M = 3.7, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.25, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brcompftssim0 <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 3.6,  M = 3.7, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.25, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim0, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.25, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim0$res
names(brsim0)
brsim0$nnyn
brsim0$tend
brsim0$downtime
names(brsim0)
brsim0$costrate
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
head(brtaus2fine)
tail(brtaus2fine)
tail(brtaus1fine)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
head(brsim1$res)
tail(brsim1$res)
tail(brsim1$res[80:85,])
tail(brsim1$res[89:83,])
tail(brsim1$res[79:83,])
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 8,  M = 12, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
failedcompsnow
rm(failedcompsnow)
failedcompsnow
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
tail(brsim1$res[79:83,])
brsim1$res[81,]
brsim1$res[81,]$tnow
brsim1$res[81,]$tnow == 8
round(8.00001, 2)
round(7.99000001, 2)
round(7.99000001, 3)
round(7.99900001, 3)
round(7.99990001, 3)
round(7.99990001, 5)
source('~/work/weibull-papers/cbm-rbd/cbm-sim.R')
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
brsim1pr <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.1, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = TRUE)
brcompftssim0 <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 3.6,  M = 3.7, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim0 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim0, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.25, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
