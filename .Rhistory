# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
ftsnowindex
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
failedcompsnow
failedcompsnow <- ftschron[ftschron <= tnow]
failedcompsnow <- ftschron[ftschron <= 7]
failedcompsnow
failedcompsnow <- ftschron[ftschron <= 2]
failedcompsnow
length(failedcompsnow)
dim(failedcompsnow)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sysnow, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
failedcompsnow <- ftschron[ftschron <= 3]
failedcompsnow
ftsnowindex
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
dim(ftsnowindex)
?sapply
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl, simplify = "matrix")
ftsnowindex
dim(ftsnowindex)
ftsnowindex <- apply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex <- lapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
as.matrix(ftsnowindex, ncol=4)
as.matrix(ftsnowindex, nrow=1)
failedcompsnow <- ftschron[ftschron <= 4]
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
failedcompsnow <- ftschron[ftschron <= 3]
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
ftsnowindex
which(ftsnowindex)
failedcompsnow
ftsnowindex
failedcompsnow[which(ftsnowindex) == 1]
ftsnow <- as.list(rep(list(NULL), K))
asdf <- as.list(rep(list(NULL), 2))
asdf
asdf[[1]] <- failedcompsnow[which(ftsnowindex) == 1]
asdf
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sysnow, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 101, prior = FALSE)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustar, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)]
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustarnow, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
br
rep(FALSE, 12)
induced_subgraph(br, vids=rep(FALSE, 12))
computeSystemSurvivalSignature(induced_subgraph(br, vids=rep(FALSE, 12)))
V(br)
computeSystemSurvivalSignature(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))
)
induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE)))
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))) == c("s", "t")
V(induced_subgraph(br, vids=c(TRUE, rep(FALSE, 9), TRUE, FALSE))) %in% c("s", "t")
sim1cycle <- function(sys, ctypes, compfts, n0y0, beta, tnowstep, hor, tprep, trepa = 0,
seqlen = 101, prior = FALSE, cu = 1, cp = 0.2, onecycle = TRUE){
K <- length(ctypes)
ftschron <- sort(unlist(compfts)) # when something fails
# initializing: initial arguments for gnowhor
tnow <- 0
sysnow <- sys
signnow <- computeSystemSurvivalSignature(sysnow)
wctnow <- 1:K       # which component types are now present in the system?
ftsnow <- as.list(rep(list(NULL), K))
gotonext = TRUE     # indicator that loop should go on
failed = FALSE      # indicator whether the system has failed
repschedfor = Inf   # for which time is repair scheduled?
res <- data.frame() # initialize results data frame
while(gotonext){
cat("tnow =", tnow,"\n")
if (!failed){ # if not failed already in previous loop, check...
if (all(signnow$Probability == 0)){ # system has failed now, schedule repair for tnow + tprep if not scheduled already
failed <- TRUE
taustarnow <- NA
if (repschedfor == Inf)
repschedfor <- tnow + tprep
} else { # system has not failed this time
if (repschedfor == Inf){ # no repair scheduled yet
# calculate current taustar
gnowvec <- gnowhor(signnow, n0y0[wctnow], beta[wctnow], ftsnow[wctnow], tnow, hor = hor,
seqlen = seqlen, prior = prior, cu = cu, cp = cp, onecycle = onecycle)
taustarnow <- gnowvec$tau[which.min(gnowvec$gnow)] - tnow
if (taustarnow <= tprep){ # schedule repair for tnow + tprep if not scheduled already
repschedfor <- tnow + tprep
} # else do nothing & go on to next loop (repschedfor is still Inf)
} else { # repair already scheduled: do nothing
taustarnow <- NA
}
} # end "system has not failed this time"
} else { # system was in failed state already at start of loop
taustarnow <- NA
}
# now we know if failed or not, if and when repair scheduled
cat("failed =", failed, "taustar =", taustarnow, "repschedfor =", repschedfor, "\n")
if (tnow >= repschedfor){ # time for repair has come, operational cycle ends
gotonext <- FALSE
}
# write all current things in results data frame
resnow <- data.frame(tnow = tnow, failed = failed, taustar = taustarnow, repschedfor = repschedfor)
res <- rbind(res, resnow)
# now prepare for next loop
tnow <- tnow + tnowstep
# update stuff if system not failed (otherwise not needed except tnow update!)
if (!failed){
failedcompsnow <- ftschron[ftschron <= tnow]
if (length(failedcompsnow) > 0){ # update stuff only when the first component has failed
# recalculates everything from scratch (do this in a more clever way?)
sysnow <- induced_subgraph(sys, vids=V(sys)[!(name %in% names(failedcompsnow))])
# TODO: catch error when sysnow now contains vertices s and t only (suddenly all fails)
signnow <- computeSystemSurvivalSignature(sysnow)
# to which fts list element do the failure times in failedcompsnow belong?
ftsnowindex <- sapply(ctypes, function(ctypesl) names(failedcompsnow) %in% ctypesl)
if (length(failedcompsnow) == 1)
ftsnowindex <- which(ftsnowindex)
else
ftsnowindex <- apply(ftsnowindex, 1, which)
# write failure times in corresponding list element
for (k in 1:K)
ftsnow[[k]] <- failedcompsnow[ftsnowindex == k]
# which component types are now present? (subset of 1:K)
wctnow <- which(names(ctypes) %in% names(signnow))
}
} # end update if system not failed
} # end while loop
# update Weibull parameters (all component types!) for next operational cycle using nnynlist() (to be defined)
# return res and all, tend = last.tnow + trepa, unit cost rate = (cp or cu) / last.tnow
return(res) # TODO: return the other stuff as well
}
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 1, trepa = 0, seqlen = 401, prior = FALSE)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.75, trepa = 0, seqlen = 401, prior = FALSE)
brcompftssim <- list(C1 = 10, C2 = 6, C3 = 7, C4 = 10, H = 8,  M = 12, P1 = 10, P2 = 3, P3 = 4, P4 = 10)
brsim1 <- sim1cycle(sys = br, ctypes = brctypes, compfts = brcompftssim, n0y0 = brn0y0, beta = brbeta,
tnowstep = 0.5, hor = 4, tprep = 0.5, trepa = 0, seqlen = 401, prior = FALSE)
brsim1
